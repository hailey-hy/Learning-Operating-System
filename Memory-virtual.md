### 1. 프로세스의 메모리 관리

- 몇몇 프로그램에 선택과 집중하여 메모리를 할당하는 방식
    - 프로세스의 빠른 수행을 위해 프로그램마다 최소한 확보해야 하는 메모리의 크기가 존재하기 때문
- 메모리 스왑 방식 활용
    - 물리적 메모리 크기에 대한 제약이 없음
- 운영체제는 프로세스 자신만의 메모리 주소 공간을 가정 → 가상 메모리
- 가상 메모리의 일부는 물리적 메모리에 적재되고 일부는 디스크의 스왑 영역에 존재
- 가상메모리 기법
    - 프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 구분
    - 요구 페이징 / 요구 세그먼테이션

### 2. 요구 페이징

1. 정의
    - 실제로 필요할 때 페이지를 메모리에 올리는 것
    - 특정 페이지에 대해 CPU의 요청이 들어온 후에야 해당 페이지를 메모리에 적재
2. 특징
    - 유효-무효 bit
        - 각 페이지가 메모리에 존재하는지 확인
        - 프로세스를 구성하는 모든 페이지에 대해 존재
        - 페이지 테이블의 각 항목별로 저장됨
    - 장점
        - I/O 양의 감소
            - 프로그램을 구성하는 주소 공간 중 빈번히 사용되는 부분은 제한적
        - Memory 사용량 감소
        - 빠른 응답 시간
        - 더 많은 사용자 수용
3. 페이지 부재
    - 정의
        - CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않음
        - 유효-무효 비트가 무효로 세팅되어 있음
    - 처리 순서
        1. 메모리 관리자 (MMU)가 페이지 부재 트랩 발생
        2. CPU 제어권이 커널모드로 전환
        3. 운영체제의 페이지 부재 처리 루틴 호출
    - 페이지 부재 처리 루틴의 처리 순서
        1. 운영체제가 해당 페이지에 대한 접근이 적법한지 체크
        2. 적법하지 않은 경우 → 해당 프로세스를 종료
            - 사용되지 않는 주소 영역에 속한 페이지에 접근하려 했을 경우
            - 해당 페이지에 대한 접근 권한을 위법했을 경우 (읽기 전용에 쓰기 시도)
        3. 적법한 경우라면 → 물리적 메모리에서 비어있는 프레임에 해당 페이지를 읽어 옴
            1. 비어 있는 프레임이 없다면 → 기존 페이지 중 하나를 스왑아웃
            2. 읽어 오는 중 → 프로세스가 봉쇄상태가 되고 디스크 입출력까지 걸리는 시간을 고려해 CPU 레지스터 값 및 프로그램 카운터값을 프로세스 제어블록에 저장
                - 입출력 후 프로세스가 다시 CPU를 할당받았을 때 같은 상태에서 다음 명령을 수행할 수 있도록 함
        4. 디스크 입출력이 완료되면 → 유효-무효 비트가 유효로 설정, 프로세스를 준비 큐로 이동시킴
4. 성능
    - 페이지 부재의 발생 빈도에 따라 성능이 결정
        - 페이지 부재 시 디스크로부터 페이지를 읽어오는 오버헤드가 막대하기 때문
    - 메모리 접근 시간인 유효 접근 시간이 짧을수록 성능이 향상됨
5. 페이지 교체
    - 페이지 부재 발생 시 물리적 메모리에 빈 프레임이 존재하지 않을 경우 수행
    - 교체 알고리즘
        - 메모리에 있는 페이지 중 어떤 페이지를 쫓아낼 것인가?
        - 페이지 부재율을 최소화 하는 것이 목표
        - 가까운 미래에 참조될 가능성이 가장 적은 페이지를 선택
        - 페이지 참조열의 페이지 부재율을 계산해 성능 측정 가능
            - 페이지 참조열: 참조되는 페이지들의 번호를 시간 순서에 따라 나열한 것
    - 교체 알고리즘의 종류
        1. 최적 페이지 교체
            - 가장 먼 미래에 참조될 페이지를 쫓아내는 방식
            - 미래에 어떤 페이지가 어떤 순서로 참조될지 미리 알고 있어야 운영 가능
                - 오프라인 알고리즘
            - 가장 적은 페이지 부재율을 보장하므로 타 알고리즘 성능에 대한 상한선 제공
        2. 선입선출 알고리즘
            - 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내쫓음
            - 비효율적인 상황 발생 가능
            - FIFO의 이상 현상
                - 메모리를 증가시켰음에도 불구하고 페이지 부재가 오히려 늘어나는 상황
        3. LRU 알고리즘
            - 시간지역성을 활용해 페이지 교체시 가장 오래전에 참조했던 페이지를 쫓아냄
            - 시간 지역성
                - 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질
            
            | 7 | 0 | 1 | 2 | 0 | 3 | 4 | 2 | 3 | 2 | 1 | 2 |
            | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
            | 7 | 7 | 7 | 2 | 2 | 2 | 4 | 4 | 4 | 4 | 4 | 4 |
            |  | 0 | 0 | 0 | 0 | 0 | 0 | 2 | 2 | 2 | 1 | 1 |
            |  |  | 1 | 1 | 1 | 3 | 3 | 3 | 3 | 3 | 3 | 2 |
            | x | x | x | x |  | x | x | x |  |  | x | x |
        4. LFU 알고리즘
            - 페이지의 참조 횟수가 가장 적었던 페이지를 쫓아냄
            - 최저 참조 횟수 페이지가 여러 개라면 임의로 하나를 선정 (가장 오래된 것으로 하도록 구현)
            1. Incache-LFU
                - 페이지가 물리적 메모리에 올라온 후부터 참조 횟수를 카운트
                - 페이지가 스왑아웃 되었다가 들어왔다면 1부터 새로 카운트
            2. Perfect-LFU
                - 메모리에 올라와 있는지 여부와 관계 없이 그 페이지의 과거 총 참조 횟수를 카운트
                - 페이지의 참조 횟수를 정확히 반영 가능 / 메모리 스왑 아웃된 페이지의 참조 기록을 보관해야 하므로 오버헤드가 더 큼
            - 장점
                - LRU 알고리즘보다 오랜 시간 동안의 참조 기록을 반영 가능
            - 단점
                - 시간에 따른 페이지 참조의 변화 반영 불가
                - 구현이 복잡함
        5. 클럭 알고리즘
            - 정의
                - 오랫동안 참조되지 않은 페이지를 교체
            - 특징
                - 하드웨어적 지원으로 동작
                    - LRU에 비해 훨씬 효율적이므로 대부분의 시스템에서 채택
                    - 적어도 시계바늘이 한 바퀴 도는 데 소요되는 시간 만큼 페이지를 메모리에 유지시킴으로써 페이지 부재율을 줄일 수 있음
            - 구현 방식
                1. 교체 페이지 선정을 위해 페이지의 참조 비트를 순차적으로 조사
                    - 참조 비트: 참조될 때 하드웨어에 의해 0에서 1로 세팅됨
                2. 참조 비트가 1이라면 → 페이지 패스
                3. 참조 비트가 0이라면 → 페이지 교체
                4. 모든 프레임을 다 조사했다면 첫 번째 페이지 프레임부터 조사 반복