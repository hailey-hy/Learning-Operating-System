### 1. 파일

1. 파일
    - 정의
        
        <aside>
        💡 논리적인 저장 단위로서 관련된 정보 자료들의 집합에 이름을 붙인 것
        
        </aside>
        
    - 특징
        - 하드디스크에 저장하는 단위
        - 일반적으로 비휘발성의 보조기억장치에 저장
        - 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 볼 수 있게 해 줌
    - 파일의 연산
        - 생성, 삭제, 읽기, 현재 접근 위치 수정(lseek), 열기, 닫기
2. 파일 메타데이터
    - 정의
        
        <aside>
        💡 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들
        
        </aside>
        
        - 파일 유형, 이름, 저장 위치, 사이즈, 접근 권한, 시간, 소유자 등
3. 파일 시스템
    - 정의
        
        <aside>
        💡 운영체제에서 파일을 관리하는 부분
        
        </aside>
        
    - 특징
        - 파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리
        - 파일의 저장 방법 결정
        - 파일 보호 등

### 2. 디렉토리와 로컬 디스크

1. 디렉토리
    - 정의
        - 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일
    - 디렉토리의 내용
        - 그 디렉토리에 속한 파일 이름 및 파일 메타데이터들
    - 특징
        - 디렉토리도 하나의 파일
        - 연산 수행 가능
            - 파일 목록 탐색, 파일 생성, 파일 삭제, 파일 이름 변경
2. 파티션
    - 정의
        
        <aside>
        💡 운영체제가 보는 논리적 디스크
        
        </aside>
        
    - 특징
        - 하나의 물리적 디스크를 쪼개 여러 파티션으로 나눠서 사용
        - 여러 개의 물리적 디스크를 하나의 파티션으로 구성하기도 함
        - 물리적 디스크를 파티션으로 구성한 뒤 각각의 파티션에 파일 시스템을 깔거나 스와핑 등의 용도로 사용 가능
    - 용도
        1. 파일 시스템
        2. 스와핑

### 3. 연산

1. open()
    - 정의
        - 파일의 메타데이터를 메모리로 올리는 것
    - 디렉토리 경로 탐색 방식 (open(”/a/b/c”)
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2bb2175a-6e61-41b5-be2e-404154e751e3/Untitled.png)
        
        1. 루트 디렉토리 “/”를 open하고 안에서 파일 “a”의 위치 획득
            
            → 커널 메모리 영역에 저장됨
            
        2. 파일 “a”를 open한 후 read하여 그 안에서 파일 “b”의 위치 획득
        3. 파일 “b”를 open한 후 read하여 그 안에서 파일 “c”의 위치 획득
        4. 파일 “c”를 open하여 read
            
            → 운영체제가 버퍼캐싱 한 후 전달
            
            - 버퍼캐싱: 다른 프로세스가 동일 파일을 요청할 경우를 대비해 파일을 복사해놓고 프로세스에 전달
    - 특징
        - 디렉토리 경로 탐색에 너무 많은 시간을 소요하므로
        - 오픈 파일 테이블
            - 글로벌하게 관리하는 공유 테이블이 1개
            - 프로세스마다 갖고 있는 테이블도 존재

### 3. 파일 접근 권한

- 각 파일에 대해 누구에게 어떤 유형의 접근을 허락할 것인가?
    - 접근: read, write, execution
- 접근 권한 관리 방법
    1. Access contorl Matrix
        - 사용 방식
            - 행에는 파일, 열에는 사용자를 나열
            - 각각의 사용자가 각각의 파일에 대해 어떤 권한이 있는지 표시
            - 실제 접근 시 Matirx를 참고해 권한이 있는 경우에만 허락
        - 단점
            - 희소 행렬 문제
                - 사용자가 파일마다 접근권한을 갖고 있지 않을 것이기 때문에 테이블 낭비
                
                → Access contorl list로 해결
                
                - 각각의 파일을 중심으로 어떤 사용자가 접근 권한이 있는지 표시
                - 사용권한이 없는 사용자는 리스트에 연결하지 않아 공간 낭비를 막음
                
                → Capablity로 해결
                
                - 각각의 사용자를 중심으로 어떤 파일에 접근 권한을 갖고 있는지 표시
                - 권한 가진 파일 목록만을 연결하여 공간 낭비 막음
            - 여전히 부가적인 오버헤드가 큼
    2. Grouping
        - 현대 운영체제에서 사용
        - 사용 방식
            - 전체 사용자를 owner, group, public의 세 그룹으로 구분
            - 사용자와 동일 그룹에 속한 사용자에 대해 접근 권한(rwx)을 3비트씩으로 표시
            
    3. Password
        - 파일마다 Password를 두는 방법
        - 사용 방식
            - 모든 접근 권한에 대해 하나의 password를 두어 all-or-nothing
        - 단점
            - 접근 권한별 password의 암기, 관리 문제

### 4. 파일 시스템의 마운팅

- 마운팅
    - 루트 파일 시스템의 특정 디렉토리 이름에 또다른 파티션 내 파일 시스템을 마운트
    - 서로 다른 파티션에 존재하는 파일 시스템에 접근할 수 있게 됨

### 5. 파일 접근 방법

- 시스템이 제공하는 파일 정보의 접근 방식
    1. 순차 접근
        - 카세트 테이프를 사용하는 방식처럼 접근
            - 이전 항목에 접근하려면 되감기
        - 읽거나 쓰면 offset은 자동적으로 증가
    2. 직접 접근(=임의 접근)
        - 레코드판과 같이 접근
            - 특정 항목에 바로 접근 가능
        - 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있음

### 6. 디스크 내 파일 데이터 할당

- 파일 데이터를 디스크에 어떻게 할당할 것인가?
1. Contiguous Allocation 연속 할당
    - 정의
        - 파일을 디스크내 블럭에 연속되게 저장하는 방식
            - 블럭: 512byte
    - 사용 방법
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c27e853a-c28f-4f02-80a0-afbfb7d0d10f/Untitled.png)
        
        - 디렉터리에 파일의 시작 부분 위치 및 파일 길이에 대한 정보를 저장하면 전체를 탐색 가능
    - 특징
        - 연속적으로 저장되어 있으므로 한번의 탐색으로 많은 양 전송 가능
        - Random Access 가능
    - 단점
        - 외부 단편화 문제 발생
        - 파일의 크기를 키우기 어려움
            - 파일이 커질 경우를 대비해 미리 큰 공간을 할당하면 내부 단편화 문제 발생
2. Linked Allocation 연결 할당
    - 정의
        - 연속적으로 할당하지 않고, 빈 위치에 자유롭게 할당될 수 있는 방식
    - 특징
        - 다음 읽어야 할 위치를 연결 리스트처럼 포인터로 가리킴
        - 디렉터리에는 파일이 시작하는 위치와 끝나는 위치만 저장됨
        - 자유롭게 할당되므로 외부 단편화가 발생하지 않음
    - 단점
        - Random Access 불가능
        - 포인터를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨림
        - 한 섹터가 고장나 포인터가 유실될 경우 많은 부분을 잃게 되어 신뢰성 문제 있음
        
        → 해결책: File allocation table
        
        - 포인터를 별도의 위치에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결
3. Indexed Allocation 색인 할당
    - 정의
        - 한 블록에 하나의 파일에 대한 데이터의 INDEX들을 모두 저장
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a70f26c2-c236-4522-a974-a546970b5a77/Untitled.png)
        
    - 특징
        - 디렉토리에는 해당 블록의 위치만 담게 됨
        - 외부 단편화가 발생하지 않음
        - Random access 가능
    - 단점
        - 작은 파일인 경우 위치를 저장하는 블록의 공간 낭비 발생
        - 너무 큰 파일인 경우 하나의 블록으로 파일의 인덱스를 모두 저장하기에 부족하게 됨

### 7. 파일시스템의 구조

1. UNIX 파일 시스템
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/191a4d25-c4d3-4e3c-9f84-658a44b9ecfd/Untitled.png)
    
    1. boot block
        - 모든 파일 시스템에 첫번째로 등장
            - 0번 블럭부터 메모리에 올리기 때문
        - 부팅에 필요한 정보가 저장됨 (boostrap loader)
    2. Superblock
        - 파일 시스템에 관한 총체적인 정보를 담고 있음
        - 어디가 비어 있고, 어디가 파일이 사용 중인 블럭인지에 관한 정보 등
    3. Inode list
        - 파일의 메타데이터 대부분을 저장
        - 파일 하나당 Inode 하나가 할당
        - 파일의 소유주, 접근권한, 최종 수정 시각, 위치 정보 등
        - 작은 Inode에 큰 정보를 담아야 하므로 네 가지 인덱스로 정보를 표현
    4. Data block
        - 디렉토리 파일에 파일의 이름만 보관
2. FAT 파일 시스템의 구조
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4614f4f5-85bd-456b-bddf-fb7a161be5c8/Untitled.png)
    
    1. boot block
    2. FAT
        - 파일의 메타데이터 중 일부(위치 정보)를 보관
            - 신뢰성, 공간 효율성 문제 해결
            - 직접 접근 가능
                - FAT은 이미 메모리에 올려져있는 상황이기때문에 특정 위치 인덱스를 바로 찾아갈 수 있음
        - 나머지 정보는 디렉토리가 보관
    3. Root directory
    4. Data block
        - 디렉토리에 파일의 위치 정보를 제외한 대부분의 정보 보관

### 8. Free-Sapce Management

1. bitmap(bit vector)
    - 각 블럭의 사용 여부를 비트(0/1)로 구분
        - 0→ free
        - 1→ occupied
    - 특징
        - 부가적인 공간을 필요로 함
        - 연속적인 n개의 빈 블럭을 찾는 데 효과적
2. Linked list
    - 모든 비어 있는 블락을 링크로 연결 (free list)
    - 특징
        - 연속적인 가용 공간을 찾는 것이 쉽지 않음
        - 공간의 낭비가 없음
3. Grouping
    - linked list의 변형
        - 첫번째 빈 공간이 N개의 포인터를 가지고
        - n - 1포인터는 빈 블럭을 가리킴
        - 마지막 포인터가 가리키는 블럭은 다시 n개의 포인터를 가짐
4. Counting
    - 프로그램들이 종종 여러 개의 연속적인 블럭을 할당하고 반납한다는 성질에 착안
    - 포인터가 빈 블럭과 함께 해당 블럭으로부터 몇 개가 비어있는지도 함께 표시
    - 특징
        - 연속된 빈 블럭 표시에 효과적

### 9. 디렉토리 구현

- 디렉토리
    - 디렉토리 하위의 파일의 메타데이터를 관리하는 특별한 파일
- 구현 방법
    1. Linear list
        - 파일 이름, 파일 메타데이터를 고정된 크기로 나열
        - 특징
            - 구현이 간단
            - 디렉토리 내 파일 탐색은 선형 탐색을 이용하므로 시간이 많이 소요
    2. Hash Table
        - 파일의 이름에 해쉬 함수를 적용, 결과값의 엔트리에 파일의 이름, 메타데이터를 저장
            - 해쉬 함수: 어떤 인풋값을 적용해도 반환값이 특정 범위 안으로 제한
        - 특징
            - 파일 탐색은 해쉬 함수에 넣어 인덱스를 찾아내서 탐색해 효율성
            - Collision 발생 가능
                - 서로 다른 파일이름에 대해 같은 결과값이 매핑
- 파일 메타데이터 보관 방식
    - 디렉토리 내에 직접 보관
    - 디렉토리에는 포인터를 두고 다른 곳에 보관
        - inode, FAT
- Long file name의 지원
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f55f3be9-427a-4866-ba64-ea3ef625e5bb/Untitled.png)
    
    - 대부분의 메타데이터는 길이가 한정되어 있음
    - 파일 이름이 고정 크기의 entry보다 길어지는 경우 entry의 마지막 부분에 이름의 뒷부분이 위치한 곳의 포인터를 둠
    - 이름의 나머지 부분은 동일한 디렉토리 파일의 일부에 존재

### 10. VFS와 NFS

1. VFS 가상 파일 시스템
    - 정의
        - 각 파일 시스템들을 동일한 시스템 콜 인터페이스로 접근할 수 있게 해주는 운영체제의 계층
            - 사용자는 파일 시스템 접근을 위해 시스템 콜을 사용
            - 파일시스템마다 다른 시스템 콜이 적용되는 혼란을 막아 줄 필요
2. NFS 네트워크 파일 시스템
    - 분산 시스템에서 원격에 저장된 파일 시스템에 접근할 수 있도록 함
    - 서버, 클라이언트 모두 NFS가 있어야 함
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf2e0fc5-16f4-42d6-8cb5-82cfde338276/Untitled.png)
    

### 11. 페이지 캐시와 버퍼 캐시

- 페이지 캐시
    - 물리적 메모리에 있는 페이지 프레임을 의미
- 버퍼 캐시
    - 파일의 데이터를 사용자가 요청했을 때 운영체제가 읽어온 내용의 일부를 저장해두어 다른 사용자의 요청에 대비함
- Unified Buffer Cahche
    - 페이지 캐시와 버퍼 캐시를 통합
    - 버퍼 캐시도 페이지 단위로, 운영체제가 같이 관리한다는 의미
- memroy mapped I/O
    - 정의
        - 주소 공간의 일부가 입출력 장치에 할당되어 그 주소로 읽거나 쓰는 것이 그 입출력 장칭로의 명령으로 해석되는 입출력 방식
    - 파일의 일정 부분을 메모리 영역에 매핑해두고 사용
    - 이후에는 메모리에 읽고 쓰지만 실제로 파일에 읽고 쓰는 효과가 나게 함

- 프로세스의 가상 메모리의 코드 부분은 실행 파일에 이미 존재하기 때문에 당장 사용되지 않는다고 해서 스왑되지 않음